#!/usr/bin/python3
#
# Test script for shadow utils
#
# Copyright (C) 2021 Olaf Kirch <okir@suse.de>

import susetest

__fips_acceptable_crypt_algos = [
	'SHA256',
	'SHA512',
]

class PWD:
	def __init__(self, user, passwd, uid, gid, gecos, home, shell):
		self.pw_name = user
		self.pw_passwd = passwd
		self.pw_uid = uid
		self.pw_gid = gid
		self.pw_gecos = gecos
		self.pw_home = home
		self.pw_shell = shell

		self.gecos_fn = None
		self.gecos_room = None

		gecos = gecos.split(',')
		if gecos:
			self.gecos_fullname = gecos.pop(0)
		if gecos:
			self.gecos_room = gecos.pop(0)

def getpwnam(node, login):
	node.logInfo("Obtaining passwd information for %s" % login)
	status = node.run("grep '^%s:' /etc/passwd" % login, stdout = bytearray(), quiet = True)
	if not status:
		node.logFailure("Could not find user %s in /etc/passwd" % login)
		return None

	fields = status.stdoutString.strip().split(':')
	return PWD(*fields)

def force_shell(node, login, shell):
	node.logInfo("Forcing %s's shell to %s" % (login, shell))
	cmd = "sed -i '/^%s:/!b;s|:[^:]*$|:%s|' /etc/passwd" % (login, shell)

	status = node.run(cmd, user = 'root', quiet = True)
	if not status:
		node.logInfo("sed command failed: %s" % status.message)
		return False

	pwd = getpwnam(node, login)
	if pwd.pw_shell != shell:
		node.logInfo("force_shell: sed command succeeded, but passwd entry for %s has shell %s" % (login, pwd.pw_shell))
		return False

	return True

def force_gecos(node, login, fullname):
	node.logInfo("Forcing %s's fullname to %s" % (login, fullname))
	cmd = "sed -i 's|^\\(%s:[^:]*:[^:]*:[^:]*:\\)[^:]*|\\1%s|' /etc/passwd" % (login, fullname)

	status = node.run(cmd, user = 'root', quiet = True)
	if not status:
		node.logInfo("sed command failed: %s" % status.message)
		return False

	pwd = getpwnam(node, login)
	if pwd.gecos_fullname != fullname:
		node.logInfo("force_shell: sed command succeeded, but passwd entry for %s has fullname %s" % (login, pwd.gecos_fullname))
		return False

	return True

@susetest.test
def verify_chfn(driver):
	'''shadow.chfn: check if test user can change GECOS information'''
	node = driver.client
	user = node.requireUser("test-user")
	if not user.uid:
		node.logFailure("user %s does not seem to exist" % user.login)
		return

	if not user.password:
		node.logFailure("user %s: password not known" % user.login)
		return

	if not force_gecos(node, user.login, "Jane Testuser"):
		node.logError("Failed to change the user's fullname")
		return

	chat_script = [
		["assword: ", user.password],
	]

	st = node.runChatScript("chfn --room 123", chat_script, timeout = 10, user = user.login)
	if st is None:
		return

	if not st:
		node.logFailure("chfn command exited with error")
		return

	pwd = getpwnam(node, user.login)
	if not pwd:
		return

	if pwd.gecos_room != '123':
		node.logFailure("Apparently, we failed to change the user info for %s." % user.login)
		return

	node.logInfo("OK, GECOS field was changed to include the phone number 123")

@susetest.test
def verify_chsh(driver):
	'''shadow.chsh: check if test user can change shell'''
	wrong_shell = "/bin/tcsh"
	good_shell = "/bin/bash"

	node = driver.client
	user = node.requireUser("test-user")
	if not user.uid:
		node.logFailure("user %s does not seem to exist" % user.login)
		return

	if not user.password:
		node.logFailure("user %s: password not known" % user.login)
		return

	if not force_shell(node, user.login, wrong_shell):
		node.logError("Failed to change the user's shell to %s" % wrong_shell)
		return

	chat_script = [
		["assword: ", user.password],
	]

	st = node.runChatScript("chsh --shell %s" % good_shell, chat_script, timeout = 10, user = user.login)
	if st is None:
		return

	if not st:
		node.logFailure("chsh command exited with error")
		return

	pwd = getpwnam(node, user.login)
	if not pwd:
		return

	if pwd.pw_shell != good_shell:
		node.logFailure("Apparently, we failed to change the shell for %s (found %s instead of %s)." % (user.login, pwd.pw_shell, good_shell))
		return

	node.logInfo("OK, shell was changed to %s." % good_shell)

@susetest.test
def verify_passwd(driver):
	'''shadow.passwd: check if test user can change password'''
	new_password = "$up3r/3l1t3/PAssw0rd"

	node = driver.client
	user = node.requireUser("test-user")
	if not user.uid:
		node.logFailure("user %s does not seem to exist" % user.login)
		return

	if not user.password:
		node.logFailure("user %s: password not known" % user.login)
		return

	node.logInfo("backing up shadow file")
	node.run("ln /etc/shadow /etc/shadow.twopence")

	chat_script = [
		["urrent password: ", user.password],
		["ew password: ", new_password],
		["password: ", new_password],
	]

	st = node.runChatScript("passwd", chat_script, timeout = 10, user = user.login)
	if st is None:
		node.logError("unable to run passwd command")
	elif not st:
		node.logFailure("passwd command exited with error")
	else:
		pass

	node.run("mv /etc/shadow.twopence /etc/shadow")
	node.logInfo("restored shadow file")

##################################################################
# IN FIPS mode, login.defs should specify the default password
# encryption method as SHA256 or SHA512
##################################################################
@susetest.test
def verify_encryption_method(driver):
	'''shadow.encryption_method: check default encyption algorithm'''

	node = driver.client
	logindefs = node.requireFile("login.defs")
	if not logindefs:
		node.logError("File login.defs does not seem to exist")
		return

	content = node.recvbuffer(logindefs.path, user = "root", quiet = True)
	if content is None:
		node.logError("Unable to retrieve login.defs")
		return

	algorithm = None

	content = content.decode('utf-8')
	for line in content.split('\n'):
		line = line.strip()
		if line.startswith('#'):
			continue
		if not line:
			continue

		w = line.split(maxsplit = 1)
		if w[0] != 'ENCRYPT_METHOD':
			continue

		algorithm = w[1].upper()

	if algorithm is None:
		node.logFailure(f"{logindefs.path} does not seem to define ENCRYPT_METHOD")
		return

	if algorithm not in ('DES', 'MD5', 'SHA256', 'SHA512', 'BCRYPT'):
		node.logFailure(f"{logindefs.path} specifies unknown encryption algorithm {algorithm}")
		return

	if node.testFeature('fips') and algorithm not in __fips_acceptable_crypt_algos:
		node.logFailure(f"{logindefs.path} specifies encryption algorithm {algorithm} (forbidden by FIPS 140-2)")
		return

	node.logInfo(f"Okay, encryption algorithm {algorithm} looks good")

##################################################################
# FIPS mode forbids DES and MD5 hash algorithms.
# It seems we're not fully disabling these; and there's probably
# a reason to keep accepting existing passwords even when hashed
# with a bad algorithm. However, we should probably make sure we
# do not accept bad algorithms when setting passwords...
# So make sure chpasswd -c $ALGO does the right thing.
##################################################################
def __verify_crypt_algo(driver, args):
	'''chpasswd.@ARGS: check whether openssl digest @ARGS works'''

	node = driver.client
	algo = args[0]

	chpasswd = node.requireExecutable("chpasswd")
	if chpasswd is None:
		node.logError("Unable to find chpasswd")
		return

	# FIXME it would be nice if our resource handling would properly
	# reset resources after use. Eg. restore the password after we've
	# messed with it
	user = node.requireUser("test-user")

	expectedToFail = node.testFeature("fips") and algo not in __fips_acceptable_crypt_algos

	data = f"{user.login}:{user.password}".encode('utf-8')
	st = chpasswd.run(f"-c {algo}", stdin = data, stdout = bytearray(), quiet = True)
	if not st:
		if not expectedToFail:
			node.logFailure(f"chpasswd with crypt algorithm {algo} failed unexpectedly")
			return

		node.logInfo(f"Good, {algo} is forbidden by FIPS 140-2, and chpasswd failed as expected")
		return

	if expectedToFail:
		node.logFailure(f"{algo} is forbidden by FIPS 140-2, but chpasswd did not fail")
		node.logInfo("Displaying user's /etc/shadow entry FYI")
		node.run(f"grep {user.login} /etc/shadow")
		return

	verify = node.requireExecutable("verify_password")
	if verify is None:
		node.logError("Unable to find verify_password executable");
		return

	st = verify.run(f"--algorithm {algo} {user.login} '{user.password}'")
	if not st:
		node.logFailure("Unable to verify password");
		return

susetest.define_parameterized(__verify_crypt_algo, "DES")
susetest.define_parameterized(__verify_crypt_algo, "MD5")
susetest.define_parameterized(__verify_crypt_algo, "SHA256")
susetest.define_parameterized(__verify_crypt_algo, "SHA512")

# boilerplate tests
susetest.template('selinux-verify-executable', 'passwd')
susetest.template('selinux-verify-executable', 'chsh')
susetest.template('selinux-verify-executable', 'chfn')


if __name__ == '__main__':
	susetest.perform()
